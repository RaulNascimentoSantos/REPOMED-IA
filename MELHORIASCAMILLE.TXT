Voc√™ √© o Claude Coder trabalhando no RepoMed IA, um app m√©dico com React/Vite (frontend) e Fastify/PostgreSQL (backend). O app tem funcionalidades prontas mas est√° com 50+ erros TypeScript no backend impedindo o build. PRIORIDADE ABSOLUTA: fazer TUDO funcionar 100% antes de adicionar features novas.
FASE 0: DIAGN√ìSTICO COMPLETO (Execute PRIMEIRO)
bash# 1. Verificar sa√∫de do projeto
cd repomed-api && npm run build 2>&1 | tee backend-errors.log
cd ../repomed-web && npm run build 2>&1 | tee frontend-errors.log

# 2. Documentar todos os erros encontrados
echo "=== ERROS TYPESCRIPT BACKEND ===" > diagnostico.md
grep -E "error TS|Error:" backend-errors.log >> diagnostico.md
echo "=== ERROS FRONTEND ===" >> diagnostico.md
grep -E "error|Error:" frontend-errors.log >> diagnostico.md

# 3. Verificar conex√µes e servi√ßos
docker-compose ps
redis-cli ping
psql $DATABASE_URL -c "SELECT 1"

# 4. Listar rotas quebradas
curl -s http://localhost:8081/api/health || echo "API DOWN"
FASE 1: CORRE√á√ÉO DE ERROS TYPESCRIPT (Urgente - Hoje)
Corrigir os 50+ erros no backend:
typescript// 1. Padronizar TODOS os imports no backend
// DE: import { something } from './file.js'
// PARA: import { something } from './file'

// 2. Resolver duplicate declarations em server.ts
// Verificar e remover redeclara√ß√µes de tipos e interfaces

// 3. Configurar tsconfig.json corretamente:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "allowJs": false,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "noUnusedLocals": false, // tempor√°rio at√© limpar c√≥digo
    "noUnusedParameters": false // tempor√°rio
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}

// 4. Adicionar tipos faltantes para Fastify plugins
npm install --save-dev @types/node @fastify/cors @fastify/jwt @fastify/multipart

// 5. Criar arquivo de tipos globais: src/types/index.d.ts
declare module 'fastify' {
  interface FastifyRequest {
    user?: {
      id: string;
      email: string;
      organizationId: string;
      role: string;
    };
  }
}
FASE 2: SISTEMA DE AUTENTICA√á√ÉO REAL (Cr√≠tico)
Implementar autentica√ß√£o funcional completa:
typescript// repomed-api/src/routes/auth.ts
import { FastifyPluginAsync } from 'fastify';
import bcrypt from 'bcryptjs';
import { z } from 'zod';

const authRoutes: FastifyPluginAsync = async (fastify) => {
  // Schema de valida√ß√£o
  const loginSchema = z.object({
    email: z.string().email(),
    password: z.string().min(6),
  });

  const registerSchema = loginSchema.extend({
    name: z.string().min(2),
    crm: z.string().regex(/^\d{4,6}$/),
    uf: z.string().length(2),
    phone: z.string().regex(/^\d{10,11}$/),
  });

  // Registro com valida√ß√£o de CRM
  fastify.post('/register', async (request, reply) => {
    try {
      const data = registerSchema.parse(request.body);
      
      // Validar CRM no CFM (API p√∫blica)
      const crmValid = await validateCRM(data.crm, data.uf);
      if (!crmValid) {
        return reply.status(400).send({ error: 'CRM inv√°lido ou inativo' });
      }
      
      // Hash da senha
      const hashedPassword = await bcrypt.hash(data.password, 10);
      
      // Criar usu√°rio no banco
      const user = await fastify.db.insert(users).values({
        ...data,
        password: hashedPassword,
        createdAt: new Date(),
      }).returning();
      
      // Gerar JWT
      const token = fastify.jwt.sign({
        id: user[0].id,
        email: user[0].email,
        organizationId: user[0].organizationId,
      });
      
      return { user: user[0], token };
    } catch (error) {
      fastify.log.error(error);
      return reply.status(400).send({ error: 'Erro no registro' });
    }
  });

  // Login
  fastify.post('/login', async (request, reply) => {
    try {
      const { email, password } = loginSchema.parse(request.body);
      
      // Buscar usu√°rio
      const user = await fastify.db.select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);
      
      if (!user[0]) {
        return reply.status(401).send({ error: 'Credenciais inv√°lidas' });
      }
      
      // Verificar senha
      const validPassword = await bcrypt.compare(password, user[0].password);
      if (!validPassword) {
        return reply.status(401).send({ error: 'Credenciais inv√°lidas' });
      }
      
      // Gerar JWT com refresh token
      const token = fastify.jwt.sign(
        { id: user[0].id, email: user[0].email },
        { expiresIn: '24h' }
      );
      
      const refreshToken = fastify.jwt.sign(
        { id: user[0].id, type: 'refresh' },
        { expiresIn: '7d' }
      );
      
      return { 
        user: user[0], 
        token,
        refreshToken,
        expiresIn: 86400 
      };
    } catch (error) {
      fastify.log.error(error);
      return reply.status(401).send({ error: 'Erro no login' });
    }
  });
};

// Valida√ß√£o de CRM via API do CFM
async function validateCRM(crm: string, uf: string): Promise<boolean> {
  try {
    // Usar API do CFM ou scraping seguro
    const response = await fetch(`https://portal.cfm.org.br/api/medicos/${crm}/${uf}`);
    const data = await response.json();
    return data.situacao === 'Ativo';
  } catch {
    // Em dev, sempre retornar true
    return process.env.NODE_ENV === 'development';
  }
}
Frontend - P√°gina de Login funcional:
tsx// repomed-web/src/pages/AuthLoginPage.tsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useNavigate } from 'react-router-dom';
import { api } from '@/lib/api';
import { useAuth } from '@/hooks/useAuth';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';

const loginSchema = z.object({
  email: z.string().email('Email inv√°lido'),
  password: z.string().min(6, 'M√≠nimo 6 caracteres'),
});

export function AuthLoginPage() {
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();
  const { login } = useAuth();
  
  const form = useForm({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });

  async function onSubmit(data: z.infer<typeof loginSchema>) {
    try {
      setIsLoading(true);
      const response = await api.post('/auth/login', data);
      
      // Salvar token e user no contexto/localStorage
      login(response.data.token, response.data.user);
      
      toast.success('Login realizado com sucesso!');
      navigate('/dashboard');
    } catch (error: any) {
      toast.error(error.response?.data?.error || 'Erro ao fazer login');
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-white">
      <div className="w-full max-w-md space-y-8 p-8 bg-white rounded-2xl shadow-xl">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900">RepoMed IA</h1>
          <p className="mt-2 text-gray-600">Entre na sua conta</p>
        </div>
        
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
          <Input
            {...form.register('email')}
            type="email"
            placeholder="seu@email.com"
            className="w-full"
          />
          
          <Input
            {...form.register('password')}
            type="password"
            placeholder="Sua senha"
            className="w-full"
          />
          
          <Button
            type="submit"
            disabled={isLoading}
            className="w-full"
          >
            {isLoading ? 'Entrando...' : 'Entrar'}
          </Button>
        </form>

        {/* Contas demo para teste */}
        <div className="mt-4 p-4 bg-blue-50 rounded-lg">
          <p className="text-sm text-gray-600">Contas demo:</p>
          <p className="text-xs">medico@demo.com / demo123</p>
          <p className="text-xs">clinica@demo.com / demo123</p>
        </div>
      </div>
    </div>
  );
}
FASE 3: TESTES E COBERTURA (Aumentar confiabilidade)
bash# Configurar testes unit√°rios e aumentar cobertura para 70%
npm install --save-dev vitest @vitest/ui @testing-library/react @testing-library/jest-dom

# vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html'],
      exclude: ['node_modules/', 'dist/'],
      thresholds: {
        branches: 70,
        functions: 70,
        lines: 70,
        statements: 70,
      },
    },
  },
});

# Criar testes para fluxos cr√≠ticos
# src/routes/__tests__/auth.test.ts
describe('Auth Routes', () => {
  it('should register a new user with valid CRM', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        email: 'test@test.com',
        password: 'Test123!',
        name: 'Dr. Test',
        crm: '12345',
        uf: 'SP',
      });
    
    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty('token');
  });

  it('should login with valid credentials', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@test.com',
        password: 'Test123!',
      });
    
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('token');
    expect(response.body).toHaveProperty('refreshToken');
  });
});
FASE 4: ASSINATURA DIGITAL REAL (Feature Core)
Implementar com VIDaaS (Gratuito pelo CFM) como primeira op√ß√£o:
typescript// repomed-api/src/services/signature.service.ts
import { VIDaaSClient } from '@cfm/vidaas-sdk'; // SDK hipot√©tico
import { BirdIDClient } from '@memed/birdid-sdk'; // Alternativa

class SignatureService {
  private vidaas: VIDaaSClient;
  private birdid: BirdIDClient;
  
  constructor() {
    // VIDaaS - Gratuito pelo CFM
    this.vidaas = new VIDaaSClient({
      environment: process.env.NODE_ENV === 'production' ? 'prod' : 'sandbox',
    });
    
    // BirdID - Backup (parceiro Memed)
    this.birdid = new BirdIDClient({
      apiKey: process.env.BIRDID_API_KEY,
    });
  }
  
  async signDocument(
    pdfBuffer: Buffer,
    doctorCRM: string,
    doctorUF: string,
    doctorCPF: string
  ) {
    try {
      // Tentar primeiro com VIDaaS (gratuito)
      const signedDoc = await this.vidaas.sign({
        document: pdfBuffer,
        signer: {
          crm: doctorCRM,
          uf: doctorUF,
          cpf: doctorCPF,
        },
        signatureType: 'PAdES', // Padr√£o ICP-Brasil
        timestamp: true, // Carimbo de tempo
      });
      
      return {
        provider: 'vidaas',
        signedPdf: signedDoc.data,
        verificationUrl: `https://validar.iti.gov.br/verificar/${signedDoc.hash}`,
      };
    } catch (error) {
      // Fallback para BirdID se VIDaaS falhar
      console.log('VIDaaS falhou, tentando BirdID...');
      
      const signedDoc = await this.birdid.documents.sign({
        file: pdfBuffer,
        signers: [{
          cpf: doctorCPF,
          type: 'medical',
          crm: doctorCRM,
        }],
      });
      
      return {
        provider: 'birdid',
        signedPdf: signedDoc.signedFile,
        verificationUrl: signedDoc.verificationUrl,
      };
    }
  }
}
FASE 5: INTEGRA√á√ÉO DE PAGAMENTO (Monetiza√ß√£o)
Stripe com Pix Recorrente + Cart√£o:
typescript// repomed-api/src/services/billing.service.ts
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

class BillingService {
  async createCheckoutSession(userId: string, plan: 'starter' | 'pro' | 'clinic') {
    const prices = {
      starter: 'price_repomed_starter_149',
      pro: 'price_repomed_pro_299',
      clinic: 'price_repomed_clinic_799',
    };
    
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card', 'pix'], // Pix + Cart√£o
      line_items: [{
        price: prices[plan],
        quantity: 1,
      }],
      mode: 'subscription',
      subscription_data: {
        trial_period_days: 14, // Trial de 14 dias
      },
      metadata: { userId },
      success_url: `${process.env.APP_URL}/dashboard?session={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.APP_URL}/pricing`,
    });
    
    return session.url;
  }
  
  // Webhook para processar eventos
  async handleWebhook(signature: string, payload: string) {
    const event = stripe.webhooks.constructEvent(
      payload,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
    
    switch (event.type) {
      case 'checkout.session.completed':
        await this.activateSubscription(event.data.object);
        break;
      case 'invoice.payment_failed':
        await this.handleFailedPayment(event.data.object);
        break;
    }
  }
}
FASE 6: CI/CD E DEPLOY (Produ√ß√£o)
GitHub Actions para deploy autom√°tico:
yaml# .github/workflows/deploy.yml
name: Deploy RepoMed IA

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Check TypeScript
        run: npm run type-check
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy Frontend to Vercel
        run: |
          npm i -g vercel
          vercel --prod --token=${{ secrets.VERCEL_TOKEN }}
      
      - name: Deploy Backend to Render
        run: |
          curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
FASE 7: MELHORIAS UX M√âDICAS (Diferencial)
Implementar features matadoras:
typescript// 1. Modo Plant√£o (Emerg√™ncia)
export function EmergencyMode() {
  const [patient, setPatient] = useState('');
  const [diagnosis, setDiagnosis] = useState('');
  
  return (
    <div className="emergency-mode p-4 max-w-md mx-auto">
      <h1 className="text-2xl font-bold mb-4">Modo Plant√£o ‚ö°</h1>
      
      {/* Busca r√°pida por CPF */}
      <Input
        placeholder="CPF do paciente"
        value={patient}
        onChange={(e) => setPatient(e.target.value)}
        className="mb-4 text-lg"
      />
      
      {/* CID-10 com autocomplete */}
      <CID10Autocomplete
        value={diagnosis}
        onChange={setDiagnosis}
        className="mb-4"
      />
      
      {/* Prescri√ß√µes favoritas */}
      <QuickPrescriptions />
      
      {/* Bot√£o gigante para gerar */}
      <Button 
        size="lg" 
        className="w-full h-16 text-xl"
        onClick={generateEmergencyPrescription}
      >
        Gerar e Assinar (Enter)
      </Button>
    </div>
  );
}

// 2. Voz para Texto M√©dico (Whisper API)
export function VoiceToText() {
  const [isRecording, setIsRecording] = useState(false);
  
  const startRecording = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    // Implementar grava√ß√£o e envio para Whisper API
  };
  
  return (
    <Button
      onMouseDown={() => setIsRecording(true)}
      onMouseUp={() => setIsRecording(false)}
      className={isRecording ? 'bg-red-500' : ''}
    >
      üé§ {isRecording ? 'Gravando...' : 'Segurar para falar'}
    </Button>
  );
}
FASE 8: MONITORAMENTO E OBSERVABILIDADE
typescript// Sentry para erro tracking
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  integrations: [
    new Sentry.Integrations.Http({ tracing: true }),
    new Sentry.Integrations.Postgres(),
  ],
  tracesSampleRate: 0.1,
  beforeSend(event) {
    // Remover dados sens√≠veis (PHI)
    delete event.user?.email;
    delete event.extra?.cpf;
    return event;
  },
});
COMANDOS DE EXECU√á√ÉO SEQUENCIAL
Execute na ordem exata:
bash# 1. Backup do estado atual
git add . && git commit -m "backup: antes das corre√ß√µes cr√≠ticas"
git checkout -b fix/critical-issues

# 2. Corrigir TypeScript (URGENTE)
cd repomed-api
npm install --save-dev @types/node @fastify/cors @fastify/jwt
# Aplicar todas as corre√ß√µes de tipos listadas acima
npm run build # Deve compilar sem erros

# 3. Implementar autentica√ß√£o real
# Copiar c√≥digo de auth.ts acima
# Atualizar frontend com AuthLoginPage.tsx
npm run dev # Testar login

# 4. Configurar testes
npm install --save-dev vitest @vitest/ui
# Criar testes b√°sicos
npm run test # Meta: 70% cobertura

# 5. Setup de produ√ß√£o
npm install stripe @sentry/node
# Configurar vari√°veis de ambiente
cp .env.example .env.production
# Adicionar secrets no GitHub

# 6. Deploy
git add . && git commit -m "fix: all critical issues resolved"
git push origin fix/critical-issues
# Criar PR e fazer merge

# 7. Deploy autom√°tico via GitHub Actions
# Ir√° deployar para Vercel (front) e Render (back)
VALIDA√á√ÉO FINAL
Checklist antes de considerar pronto:

 Backend compila sem erros TypeScript
 Login/registro funcionando com JWT
 Valida√ß√£o de CRM integrada
 Assinatura digital com VIDaaS ou BirdID
 Pagamento com Stripe (Pix + Cart√£o)
 Cobertura de testes > 70%
 Deploy autom√°tico configurado
 Monitoramento com Sentry ativo
 Modo plant√£o implementado
 Performance < 2s para carregar dashboard
 0 erros no console do browser
 Lighthouse score > 90

EXTENS√ïES VSCODE NECESS√ÅRIAS
Adicione ao .vscode/extensions.json se n√£o tiver:
json{
  "recommendations": [
    // J√° tem 67, adicionar estas cr√≠ticas:
    "prisma.prisma", // Para schema do banco
    "stripe.vscode-stripe", // Integra√ß√£o Stripe
    "github.vscode-github-actions", // CI/CD
    "orta.vscode-jest", // Testes
    "ZixuanChen.vitest-explorer", // Vitest UI
    "mermaid-preview", // Diagramas
    "hashicorp.terraform", // Infra as Code
    "ms-kubernetes-tools.vscode-kubernetes-tools" // Se usar K8s
  ]
}

INSTRU√á√ïES FINAIS PARA O CLAUDE CODER:

Execute FASE 0 primeiro - documente todos os problemas
Corrija TypeScript antes de qualquer outra coisa
Teste cada corre√ß√£o antes de avan√ßar
Commite frequentemente com mensagens descritivas
N√£o adicione features novas at√© tudo estar 100% funcional
Use as certificadoras na ordem: VIDaaS (gr√°tis CFM) ‚Üí BirdID (Memed) ‚Üí SafeID
Mantenha o que j√° funciona - n√£o refatore sem necessidade
Documente mudan√ßas cr√≠ticas em um CHANGELOG.md

Resultado esperado: App 100% funcional, sem erros, com autentica√ß√£o real, assinatura digital v√°lida juridicamente, pagamento configurado e pronto para receber os primeiros clientes pagantes em produ√ß√£o.