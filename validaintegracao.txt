# ğŸ”Œ PROMPT INTEGRATION MASTER - ValidaÃ§Ã£o Total Backend â†”ï¸ Frontend

## ğŸ¯ MISSÃƒO ESPECÃFICA
VocÃª Ã© um **Integration QA Engineer** especializado em validar comunicaÃ§Ã£o entre sistemas. Sua missÃ£o Ã© testar CADA rota do backend com CADA chamada do frontend, garantindo 100% de integraÃ§Ã£o funcional. Onde encontrar desconexÃ£o, vocÃª deve CORRIGIR imediatamente.

## ğŸ” METODOLOGIA DE VALIDAÃ‡ÃƒO DE INTEGRAÃ‡ÃƒO

### PRINCÃPIO: Map â†’ Test â†’ Fix â†’ Verify
```bash
# Setup inicial para validaÃ§Ã£o
npm run dev:full  # Backend (3333) + Frontend (5173)

# Ferramentas de interceptaÃ§Ã£o
npm install -D msw @mswjs/data  # Mock Service Worker
npm install -D axios-mock-adapter  # Para testes
npm install -D newman  # Para rodar Postman collections
```

## ğŸ“‹ MAPEAMENTO COMPLETO DE ROTAS E INTEGRAÃ‡Ã•ES

### 1ï¸âƒ£ **INVENTÃRIO DE ROTAS BACKEND**
```typescript
// tests/integration/backend-routes-inventory.ts
const BACKEND_ROUTES = {
  // AUTENTICAÃ‡ÃƒO
  auth: {
    login: { method: 'POST', path: '/auth/login', body: { email: string, password: string } },
    refresh: { method: 'POST', path: '/auth/refresh', body: { refreshToken: string } },
    logout: { method: 'POST', path: '/auth/logout' },
    register: { method: 'POST', path: '/auth/register', body: { email: string, password: string, name: string, crm?: string } }
  },
  
  // PACIENTES
  patients: {
    list: { method: 'GET', path: '/api/patients', query: { page?: number, limit?: number, search?: string } },
    get: { method: 'GET', path: '/api/patients/:id' },
    create: { method: 'POST', path: '/api/patients', body: { name: string, cpf: string, email?: string } },
    update: { method: 'PUT', path: '/api/patients/:id', body: { partial: true } },
    delete: { method: 'DELETE', path: '/api/patients/:id' },
    search: { method: 'GET', path: '/api/patients/search', query: { q: string } }
  },
  
  // TEMPLATES
  templates: {
    list: { method: 'GET', path: '/api/templates', query: { category?: string, active?: boolean } },
    get: { method: 'GET', path: '/api/templates/:id' },
    create: { method: 'POST', path: '/api/templates', body: { name: string, fields: object } },
    update: { method: 'PUT', path: '/api/templates/:id' },
    delete: { method: 'DELETE', path: '/api/templates/:id' },
    categories: { method: 'GET', path: '/api/templates/categories' }
  },
  
  // DOCUMENTOS
  documents: {
    list: { method: 'GET', path: '/api/documents', query: { status?: string, patientId?: string } },
    get: { method: 'GET', path: '/api/documents/:id' },
    create: { method: 'POST', path: '/api/documents', body: { templateId: string, patientId: string, content: object } },
    update: { method: 'PUT', path: '/api/documents/:id' },
    delete: { method: 'DELETE', path: '/api/documents/:id' },
    sign: { method: 'POST', path: '/api/documents/:id/sign', body: { password?: string } },
    pdf: { method: 'GET', path: '/api/documents/:id/pdf' },
    share: { method: 'POST', path: '/api/documents/:id/share', body: { expiresIn?: string, password?: string } },
    verify: { method: 'GET', path: '/api/documents/verify/:hash' },
    audit: { method: 'GET', path: '/api/audit/:documentId' }
  },
  
  // PRESCRIÃ‡Ã•ES
  prescriptions: {
    list: { method: 'GET', path: '/api/prescriptions' },
    get: { method: 'GET', path: '/api/prescriptions/:id' },
    create: { method: 'POST', path: '/api/prescriptions', body: { patientId: string, medications: array } },
    update: { method: 'PUT', path: '/api/prescriptions/:id' },
    delete: { method: 'DELETE', path: '/api/prescriptions/:id' }
  },
  
  // ASSINATURAS
  signatures: {
    request: { method: 'POST', path: '/api/signatures/request', body: { documentId: string } },
    verify: { method: 'POST', path: '/api/signatures/verify', body: { token: string } },
    sign: { method: 'POST', path: '/api/signatures/sign', body: { requestId: string, password: string } },
    status: { method: 'GET', path: '/api/signatures/status/:requestId' }
  },
  
  // MÃ‰TRICAS
  metrics: {
    dashboard: { method: 'GET', path: '/api/metrics/dashboard' },
    performance: { method: 'GET', path: '/api/metrics/performance' },
    cache: { method: 'GET', path: '/api/metrics/cache' },
    health: { method: 'GET', path: '/api/metrics/health' }
  },
  
  // UPLOAD
  upload: {
    file: { method: 'POST', path: '/api/upload', body: FormData }
  },
  
  // SHARES PÃšBLICAS
  public: {
    share: { method: 'GET', path: '/api/documents/share/:token' },
    verify: { method: 'GET', path: '/api/documents/verify/:hash' }
  }
}
```

### 2ï¸âƒ£ **MAPEAMENTO DE HOOKS/CHAMADAS FRONTEND**
```typescript
// tests/integration/frontend-api-calls-inventory.ts
const FRONTEND_API_CALLS = {
  // src/hooks/useApi.js
  useAuth: {
    login: 'POST /auth/login',
    logout: 'POST /auth/logout',
    refresh: 'POST /auth/refresh',
    register: 'POST /auth/register'
  },
  
  // src/hooks/usePatients.ts
  usePatients: {
    list: 'GET /api/patients',
    get: 'GET /api/patients/:id',
    create: 'POST /api/patients',
    update: 'PUT /api/patients/:id',
    delete: 'DELETE /api/patients/:id'
  },
  
  // src/hooks/useDocuments.ts
  useDocuments: {
    list: 'GET /api/documents',
    create: 'POST /api/documents',
    sign: 'POST /api/documents/:id/sign',
    generatePDF: 'GET /api/documents/:id/pdf',
    share: 'POST /api/documents/:id/share'
  },
  
  // TanStack Query keys
  queryKeys: [
    ['patients'],
    ['patients', id],
    ['documents'],
    ['documents', id],
    ['templates'],
    ['templates', id],
    ['metrics', 'dashboard'],
    ['prescriptions']
  ]
}
```

## ğŸ§ª TESTES DE INTEGRAÃ‡ÃƒO COMPLETOS

### 3ï¸âƒ£ **VALIDAÃ‡ÃƒO DE CADA ENDPOINT**
```typescript
// tests/integration/endpoint-validation.spec.ts
import { test, expect } from '@playwright/test'
import axios from 'axios'

const API_BASE = 'http://localhost:3333'
const FRONTEND = 'http://localhost:5173'

test.describe('ValidaÃ§Ã£o Completa de Endpoints', () => {
  
  // TESTE PARA CADA ROTA DO BACKEND
  test.describe('Auth Endpoints', () => {
    test('POST /auth/login - Frontend chama corretamente', async ({ page }) => {
      // 1. Interceptar request do frontend
      const requestPromise = page.waitForRequest(req => 
        req.url().includes('/auth/login') && req.method() === 'POST'
      )
      
      // 2. Executar aÃ§Ã£o no frontend
      await page.goto(`${FRONTEND}/auth/login`)
      await page.fill('input[name="email"]', 'test@example.com')
      await page.fill('input[name="password"]', 'password123')
      await page.click('button[type="submit"]')
      
      // 3. Validar request
      const request = await requestPromise
      const postData = request.postDataJSON()
      
      expect(postData).toEqual({
        email: 'test@example.com',
        password: 'password123'
      })
      
      // 4. Validar response handling
      const response = await request.response()
      expect(response.status()).toBeLessThan(400)
      
      // 5. Validar que frontend processa response
      await expect(page).toHaveURL(/\/home|\/dashboard/)
    })
    
    test('POST /auth/logout - Limpa estado corretamente', async ({ page }) => {
      // Login primeiro
      await loginUser(page)
      
      // Interceptar logout
      const logoutPromise = page.waitForRequest(req => 
        req.url().includes('/auth/logout')
      )
      
      // Executar logout
      await page.click('button[aria-label="Logout"]')
      
      // Validar request
      await logoutPromise
      
      // Validar limpeza de estado
      const localStorage = await page.evaluate(() => window.localStorage)
      expect(localStorage.token).toBeUndefined()
      
      // Validar redirect
      await expect(page).toHaveURL('/auth/login')
    })
  })
  
  test.describe('Patients CRUD - IntegraÃ§Ã£o Completa', () => {
    test('Lista de Pacientes - PaginaÃ§Ã£o funciona', async ({ page }) => {
      await page.goto(`${FRONTEND}/patients`)
      
      // Validar primeira pÃ¡gina
      const firstPageRequest = page.waitForRequest(req => 
        req.url().includes('/api/patients?page=1')
      )
      await firstPageRequest
      
      // Clicar prÃ³xima pÃ¡gina
      await page.click('button[aria-label="Next page"]')
      
      // Validar segunda pÃ¡gina
      const secondPageRequest = page.waitForRequest(req => 
        req.url().includes('/api/patients?page=2')
      )
      await secondPageRequest
      
      // Validar que dados mudaram
      const patients = await page.locator('[data-testid="patient-row"]').count()
      expect(patients).toBeGreaterThan(0)
    })
    
    test('Criar Paciente - Fluxo completo', async ({ page }) => {
      await page.goto(`${FRONTEND}/patients/create`)
      
      // Preencher form
      await page.fill('input[name="name"]', 'JoÃ£o Silva')
      await page.fill('input[name="cpf"]', '123.456.789-00')
      await page.fill('input[name="email"]', 'joao@example.com')
      
      // Interceptar POST
      const createPromise = page.waitForRequest(req => 
        req.url().includes('/api/patients') && req.method() === 'POST'
      )
      
      // Submit
      await page.click('button[type="submit"]')
      
      // Validar request
      const request = await createPromise
      const body = request.postDataJSON()
      
      expect(body).toMatchObject({
        name: 'JoÃ£o Silva',
        cpf: '12345678900', // Sem mÃ¡scara
        email: 'joao@example.com'
      })
      
      // Validar redirect apÃ³s sucesso
      await page.waitForURL(/\/patients\/[a-f0-9-]+/)
    })
  })
  
  test.describe('Documents - Ciclo Completo', () => {
    test('Criar â†’ Assinar â†’ PDF â†’ Compartilhar', async ({ page }) => {
      // 1. CRIAR DOCUMENTO
      await page.goto(`${FRONTEND}/documents/new`)
      
      const createRequest = page.waitForRequest(req => 
        req.url().includes('/api/documents') && req.method() === 'POST'
      )
      
      await page.selectOption('select[name="templateId"]', { index: 1 })
      await page.selectOption('select[name="patientId"]', { index: 1 })
      await page.fill('textarea[name="content"]', 'ConteÃºdo mÃ©dico')
      await page.click('button:has-text("Salvar")')
      
      const created = await createRequest
      const response = await created.response()
      const { id } = await response.json()
      
      // 2. ASSINAR DOCUMENTO
      await page.goto(`${FRONTEND}/documents/${id}`)
      
      const signRequest = page.waitForRequest(req => 
        req.url().includes(`/api/documents/${id}/sign`)
      )
      
      await page.click('button:has-text("Assinar")')
      await page.fill('input[name="password"]', 'senha123')
      await page.click('button:has-text("Confirmar")')
      
      await signRequest
      
      // 3. GERAR PDF
      const pdfRequest = page.waitForRequest(req => 
        req.url().includes(`/api/documents/${id}/pdf`)
      )
      
      await page.click('button:has-text("Gerar PDF")')
      await pdfRequest
      
      // 4. COMPARTILHAR
      const shareRequest = page.waitForRequest(req => 
        req.url().includes(`/api/documents/${id}/share`)
      )
      
      await page.click('button:has-text("Compartilhar")')
      await page.selectOption('select[name="expiresIn"]', '7d')
      await page.click('button:has-text("Gerar Link")')
      
      const shareResponse = await (await shareRequest).response()
      const { shareUrl } = await shareResponse.json()
      
      expect(shareUrl).toContain('/share/')
    })
  })
})
```

### 4ï¸âƒ£ **VALIDAÃ‡ÃƒO DE HEADERS E AUTH**
```typescript
// tests/integration/headers-auth-validation.spec.ts
test.describe('Headers e AutenticaÃ§Ã£o', () => {
  test('Token JWT enviado em todas requests autenticadas', async ({ page }) => {
    await loginUser(page)
    
    // Interceptar qualquer request
    page.on('request', request => {
      if (request.url().includes('/api/') && !request.url().includes('/auth/')) {
        const headers = request.headers()
        expect(headers['authorization']).toMatch(/^Bearer .+/)
      }
    })
    
    // Navegar por pÃ¡ginas protegidas
    await page.goto(`${FRONTEND}/patients`)
    await page.goto(`${FRONTEND}/documents`)
    await page.goto(`${FRONTEND}/templates`)
  })
  
  test('CORS headers corretos', async () => {
    const response = await axios.options(`${API_BASE}/api/patients`)
    
    expect(response.headers['access-control-allow-origin']).toBeTruthy()
    expect(response.headers['access-control-allow-methods']).toContain('GET')
    expect(response.headers['access-control-allow-headers']).toContain('authorization')
  })
  
  test('401 redireciona para login', async ({ page }) => {
    // ForÃ§ar token invÃ¡lido
    await page.evaluate(() => {
      localStorage.setItem('token', 'invalid-token')
    })
    
    await page.goto(`${FRONTEND}/patients`)
    
    // Deve redirecionar
    await page.waitForURL('/auth/login')
    
    // Token deve ser limpo
    const token = await page.evaluate(() => localStorage.getItem('token'))
    expect(token).toBeNull()
  })
})
```

### 5ï¸âƒ£ **VALIDAÃ‡ÃƒO DE QUERY PARAMS E FILTROS**
```typescript
// tests/integration/query-filters-validation.spec.ts
test.describe('Query Parameters e Filtros', () => {
  test('Filtros de pacientes funcionam', async ({ page }) => {
    await page.goto(`${FRONTEND}/patients`)
    
    // Busca por nome
    await page.fill('input[name="search"]', 'JoÃ£o')
    
    const searchRequest = page.waitForRequest(req => {
      const url = new URL(req.url())
      return url.searchParams.get('search') === 'JoÃ£o'
    })
    
    await searchRequest
    
    // Filtro por gÃªnero
    await page.selectOption('select[name="gender"]', 'M')
    
    const genderRequest = page.waitForRequest(req => {
      const url = new URL(req.url())
      return url.searchParams.get('gender') === 'M'
    })
    
    await genderRequest
  })
  
  test('PaginaÃ§Ã£o envia params corretos', async ({ page }) => {
    await page.goto(`${FRONTEND}/documents`)
    
    // Mudar items per page
    await page.selectOption('select[name="limit"]', '50')
    
    const limitRequest = page.waitForRequest(req => {
      const url = new URL(req.url())
      return url.searchParams.get('limit') === '50'
    })
    
    await limitRequest
  })
})
```

### 6ï¸âƒ£ **VALIDAÃ‡ÃƒO DE UPLOADS E MULTIPART**
```typescript
// tests/integration/upload-validation.spec.ts
test.describe('Upload de Arquivos', () => {
  test('Upload envia FormData corretamente', async ({ page }) => {
    await page.goto(`${FRONTEND}/upload`)
    
    // Selecionar arquivo
    const fileInput = page.locator('input[type="file"]')
    await fileInput.setInputFiles({
      name: 'test.pdf',
      mimeType: 'application/pdf',
      buffer: Buffer.from('PDF content')
    })
    
    // Interceptar upload
    const uploadRequest = page.waitForRequest(req => {
      const headers = req.headers()
      return (
        req.url().includes('/api/upload') &&
        headers['content-type'].includes('multipart/form-data')
      )
    })
    
    await page.click('button:has-text("Upload")')
    
    const request = await uploadRequest
    expect(request.method()).toBe('POST')
  })
  
  test('Progress bar funciona', async ({ page }) => {
    await page.goto(`${FRONTEND}/upload`)
    
    // Mock slow upload
    await page.route('**/api/upload', async route => {
      await page.waitForTimeout(2000) // Simular upload lento
      await route.fulfill({ status: 200, body: JSON.stringify({ url: 'test.pdf' }) })
    })
    
    await page.setInputFiles('input[type="file"]', 'test.pdf')
    await page.click('button:has-text("Upload")')
    
    // Progress deve aparecer
    await expect(page.locator('[role="progressbar"]')).toBeVisible()
    
    // E depois sumir
    await expect(page.locator('[role="progressbar"]')).toBeHidden({ timeout: 5000 })
  })
})
```

### 7ï¸âƒ£ **VALIDAÃ‡ÃƒO DE CACHE E INVALIDAÃ‡ÃƒO**
```typescript
// tests/integration/cache-validation.spec.ts
test.describe('Cache e InvalidaÃ§Ã£o', () => {
  test('React Query cache funciona', async ({ page }) => {
    let requestCount = 0
    
    // Contar requests
    page.on('request', req => {
      if (req.url().includes('/api/patients')) {
        requestCount++
      }
    })
    
    // Primeira visita
    await page.goto(`${FRONTEND}/patients`)
    await page.waitForLoadState('networkidle')
    
    const firstCount = requestCount
    
    // Segunda visita (deve usar cache)
    await page.goto(`${FRONTEND}/home`)
    await page.goto(`${FRONTEND}/patients`)
    await page.waitForLoadState('networkidle')
    
    // NÃ£o deve ter feito nova request
    expect(requestCount).toBe(firstCount)
  })
  
  test('Mutation invalida cache', async ({ page }) => {
    await page.goto(`${FRONTEND}/patients`)
    
    // Criar paciente
    await page.click('button:has-text("Novo Paciente")')
    await page.fill('input[name="name"]', 'Teste Cache')
    await page.click('button[type="submit"]')
    
    // Deve refazer request da lista
    const refetchRequest = page.waitForRequest(req => 
      req.url().includes('/api/patients') && req.method() === 'GET'
    )
    
    await refetchRequest
  })
})
```

### 8ï¸âƒ£ **VALIDAÃ‡ÃƒO DE ERROS E RETRY**
```typescript
// tests/integration/error-handling-validation.spec.ts
test.describe('Tratamento de Erros', () => {
  test('Erro 500 mostra mensagem amigÃ¡vel', async ({ page }) => {
    // Mock erro 500
    await page.route('**/api/patients', route => {
      route.fulfill({
        status: 500,
        contentType: 'application/problem+json',
        body: JSON.stringify({
          type: '/errors/internal-server-error',
          title: 'Internal Server Error',
          status: 500,
          detail: 'Database connection failed'
        })
      })
    })
    
    await page.goto(`${FRONTEND}/patients`)
    
    // Deve mostrar erro
    await expect(page.locator('text=Erro ao carregar')).toBeVisible()
    
    // BotÃ£o retry deve aparecer
    await expect(page.locator('button:has-text("Tentar Novamente")')).toBeVisible()
  })
  
  test('Retry funciona apÃ³s erro', async ({ page }) => {
    let attempts = 0
    
    await page.route('**/api/documents', route => {
      attempts++
      if (attempts === 1) {
        // Primeira tentativa falha
        route.fulfill({ status: 500 })
      } else {
        // Segunda tentativa sucesso
        route.fulfill({ 
          status: 200, 
          body: JSON.stringify([]) 
        })
      }
    })
    
    await page.goto(`${FRONTEND}/documents`)
    
    // Erro aparece
    await expect(page.locator('text=Erro')).toBeVisible()
    
    // Clicar retry
    await page.click('button:has-text("Tentar Novamente")')
    
    // Sucesso
    await expect(page.locator('text=Erro')).toBeHidden()
  })
})
```

## ğŸ”§ CORREÃ‡Ã•ES AUTOMÃTICAS DE INTEGRAÃ‡ÃƒO

### PADRÃ•ES DE CORREÃ‡ÃƒO
```typescript
// PROBLEMA 1: Frontend chamando rota errada
FIX_WRONG_ROUTE: {
  file: 'src/hooks/useApi.js',
  find: '/api/patient/', // Errado
  replace: '/api/patients/', // Correto
}

// PROBLEMA 2: Token nÃ£o sendo enviado
FIX_MISSING_TOKEN: {
  file: 'src/lib/api.ts',
  add: `
    axios.interceptors.request.use(config => {
      const token = localStorage.getItem('token')
      if (token) {
        config.headers.Authorization = \`Bearer \${token}\`
      }
      return config
    })
  `
}

// PROBLEMA 3: Query params nÃ£o sendo enviados
FIX_QUERY_PARAMS: {
  file: 'src/hooks/usePatients.ts',
  change: `
    // De:
    const { data } = useQuery(['patients'], () => 
      api.get('/api/patients')
    )
    
    // Para:
    const { data } = useQuery(['patients', filters], () => 
      api.get('/api/patients', { params: filters })
    )
  `
}

// PROBLEMA 4: FormData para upload
FIX_UPLOAD_FORMDATA: {
  file: 'src/pages/Upload.tsx',
  change: `
    const handleUpload = async (file: File) => {
      const formData = new FormData()
      formData.append('file', file)
      
      await api.post('/api/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      })
    }
  `
}

// PROBLEMA 5: Erro nÃ£o tratado
FIX_ERROR_HANDLING: {
  file: 'src/hooks/useDocuments.ts',
  add: `
    const mutation = useMutation({
      mutationFn: createDocument,
      onError: (error) => {
        if (error.response?.data?.detail) {
          toast.error(error.response.data.detail)
        } else {
          toast.error('Erro ao criar documento')
        }
      }
    })
  `
}
```

## ğŸ“Š MATRIZ DE COMPATIBILIDADE

### VALIDAÃ‡ÃƒO CRUZADA
```typescript
// tests/integration/compatibility-matrix.spec.ts
const COMPATIBILITY_MATRIX = [
  // [Frontend Route, Backend Endpoint, Expected Status]
  ['/patients', 'GET /api/patients', 200],
  ['/patients/create', 'POST /api/patients', 201],
  ['/patients/:id', 'GET /api/patients/:id', 200],
  ['/patients/:id/edit', 'PUT /api/patients/:id', 200],
  ['/documents', 'GET /api/documents', 200],
  ['/documents/new', 'POST /api/documents', 201],
  ['/documents/:id', 'GET /api/documents/:id', 200],
  ['/documents/:id/sign', 'POST /api/documents/:id/sign', 200],
  ['/templates', 'GET /api/templates', 200],
  ['/prescriptions/create', 'POST /api/prescriptions', 201],
  ['/metrics', 'GET /api/metrics/dashboard', 200],
  ['/upload', 'POST /api/upload', 200],
]

test.describe('Matriz de Compatibilidade', () => {
  for (const [route, endpoint, status] of COMPATIBILITY_MATRIX) {
    test(`${route} â†’ ${endpoint}`, async ({ page }) => {
      const [method, path] = endpoint.split(' ')
      
      // Interceptar request
      const requestPromise = page.waitForRequest(req => 
        req.url().includes(path.replace(':id', '')) && 
        req.method() === method
      )
      
      // Navegar para rota
      await page.goto(`${FRONTEND}${route.replace(':id', 'test-id')}`)
      
      // Validar request
      const request = await requestPromise
      const response = await request.response()
      
      expect(response.status()).toBe(status)
    })
  }
})
```

## ğŸš€ SCRIPT DE EXECUÃ‡ÃƒO COMPLETA

```bash
#!/bin/bash
# integration-validation.sh

echo "ğŸ”Œ Iniciando ValidaÃ§Ã£o de IntegraÃ§Ã£o Backend â†”ï¸ Frontend"

# 1. Verificar serviÃ§os rodando
echo "âœ“ Verificando serviÃ§os..."
curl -f http://localhost:3333/health || (echo "âŒ Backend nÃ£o estÃ¡ rodando" && exit 1)
curl -f http://localhost:5173 || (echo "âŒ Frontend nÃ£o estÃ¡ rodando" && exit 1)

# 2. Gerar documentaÃ§Ã£o de rotas
echo "ğŸ“„ Gerando documentaÃ§Ã£o de APIs..."
curl http://localhost:3333/docs/json > backend-routes.json
npm run generate:api-types  # Se existir

# 3. Validar contratos
echo "ğŸ“ Validando contratos..."
npx playwright test tests/integration/backend-routes-inventory.spec.ts

# 4. Testar cada integraÃ§Ã£o
echo "ğŸ§ª Testando integraÃ§Ãµes..."
npx playwright test tests/integration/endpoint-validation.spec.ts --headed

# 5. Validar headers e auth
echo "ğŸ” Validando autenticaÃ§Ã£o..."
npx playwright test tests/integration/headers-auth-validation.spec.ts

# 6. Testar query params
echo "ğŸ” Validando query parameters..."
npx playwright test tests/integration/query-filters-validation.spec.ts

# 7. Testar uploads
echo "ğŸ“¤ Validando uploads..."
npx playwright test tests/integration/upload-validation.spec.ts

# 8. Validar cache
echo "ğŸ’¾ Validando cache..."
npx playwright test tests/integration/cache-validation.spec.ts

# 9. Testar erros
echo "âŒ Validando tratamento de erros..."
npx playwright test tests/integration/error-handling-validation.spec.ts

# 10. Matriz de compatibilidade
echo "ğŸ“Š Executando matriz de compatibilidade..."
npx playwright test tests/integration/compatibility-matrix.spec.ts

# 11. Gerar relatÃ³rio
echo "ğŸ“ˆ Gerando relatÃ³rio..."
node scripts/generate-integration-report.js

echo "âœ… ValidaÃ§Ã£o de IntegraÃ§Ã£o Completa!"
echo "ğŸ“„ RelatÃ³rio: ./integration-report.html"
```

## ğŸ“ˆ RELATÃ“RIO DE INTEGRAÃ‡ÃƒO

### TEMPLATE DO RELATÃ“RIO
```html
<!DOCTYPE html>
<html>
<head>
  <title>Integration Report - RepoMed IA</title>
  <style>
    .endpoint { display: flex; justify-content: space-between; padding: 10px; }
    .success { background: #d4edda; }
    .error { background: #f8d7da; }
    .warning { background: #fff3cd; }
  </style>
</head>
<body>
  <h1>Backend â†”ï¸ Frontend Integration Report</h1>
  
  <section>
    <h2>Summary</h2>
    <div>Total Endpoints: <b>85</b></div>
    <div>Connected: <b class="success">78</b></div>
    <div>Disconnected: <b class="error">5</b></div>
    <div>Not Used: <b class="warning">2</b></div>
  </section>
  
  <section>
    <h2>Endpoint Status</h2>
    <div class="endpoint success">
      <span>GET /api/patients</span>
      <span>âœ… Connected</span>
      <span>Used in: PatientsPage.tsx</span>
    </div>
    <!-- Mais endpoints... -->
  </section>
  
  <section>
    <h2>Issues Fixed</h2>
    <ol>
      <li>Token not being sent in /api/documents requests - FIXED</li>
      <li>Wrong endpoint /api/patient/ â†’ /api/patients/ - FIXED</li>
      <!-- Mais correÃ§Ãµes... -->
    </ol>
  </section>
</body>
</html>
```

## âœ… CRITÃ‰RIOS DE SUCESSO

A integraÃ§Ã£o estÃ¡ perfeita quando:

âœ“ **100% das rotas** backend tÃªm chamada correspondente no frontend  
âœ“ **Todos os tokens** sÃ£o enviados corretamente  
âœ“ **Query params** funcionam em filtros e paginaÃ§Ã£o  
âœ“ **Uploads** funcionam com progress bar  
âœ“ **Erros** sÃ£o tratados e exibidos corretamente  
âœ“ **Cache** funciona e invalida quando necessÃ¡rio  
âœ“ **Auth flow** completo sem falhas  
âœ“ **Public routes** acessÃ­veis sem login  
âœ“ **CORS** configurado corretamente  
âœ“ **Response types** match frontend expectations  

---

**IMPORTANTE**: Execute este prompt APÃ“S validar frontend e backend separadamente. Este Ã© o teste final de integraÃ§Ã£o total do sistema.