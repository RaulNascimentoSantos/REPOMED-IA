PARTE 1: CORREÇÕES IMEDIATAS NO FRONTEND
1.1 CORRIGIR MedicalWorkspace.tsx
tsx// ATUALIZAR ARQUIVO: repomed-web/src/layouts/MedicalWorkspace.tsx

// Adicionar imports faltantes no topo
import { cn } from '@/lib/utils';
import { Link } from 'react-router-dom';
import { useEffect } from 'react';

// Substituir o map de navigation (linha ~55-70) por:
{navigation.map((item) => (
  <Link
    key={item.name}
    to={item.href}
    className="flex items-center justify-between px-3 py-2 rounded-lg hover:bg-neutral-100 transition-colors group"
    aria-label={item.name}
    aria-current={location.pathname === item.href ? 'page' : undefined}
  >
    <div className="flex items-center gap-3">
      <item.icon 
        className="w-5 h-5 text-neutral-500 group-hover:text-primary-500" 
        aria-hidden="true"
      />
      <span className="text-sm font-medium text-neutral-700">{item.name}</span>
    </div>
    {item.badge && (
      <span 
        className="bg-primary-100 text-primary-600 text-xs font-medium px-2 py-0.5 rounded-full"
        aria-label={`${item.badge} itens`}
      >
        {item.badge}
      </span>
    )}
  </Link>
))}

// Adicionar tipagem para activePanel
type PanelType = 'patient' | 'editor' | 'validation';
const [activePanel, setActivePanel] = useState<PanelType>('editor');

// Adicionar aria-labels nos painéis colapsados
<div 
  className={cn(
    'w-80 bg-white border-r border-neutral-200 transition-all duration-300',
    activePanel !== 'patient' && 'w-12'
  )}
  aria-expanded={activePanel === 'patient'}
  aria-label="Painel do Paciente"
>
1.2 MELHORAR Button.tsx com Acessibilidade
tsx// ATUALIZAR ARQUIVO: repomed-web/src/components/ui/Button.tsx

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ 
    className, 
    variant, 
    size, 
    fullWidth, 
    loading, 
    leftIcon, 
    rightIcon, 
    children, 
    disabled,
    type = 'button', // Default type
    ...props 
  }, ref) => {
    return (
      <button
        ref={ref}
        type={type}
        className={cn(buttonVariants({ variant, size, fullWidth }), className)}
        disabled={disabled || loading}
        aria-busy={loading ? 'true' : 'false'}
        aria-disabled={disabled || loading ? 'true' : 'false'}
        {...props}
      >
        {loading ? (
          <Loader2 className="animate-spin" aria-label="Carregando" />
        ) : leftIcon}
        <span>{children}</span>
        {!loading && rightIcon}
      </button>
    );
  }
);
1.3 CRIAR COMPONENTES DE ESTADO PADRONIZADOS
tsx// CRIAR ARQUIVO: repomed-web/src/components/ui/States.tsx

import { AlertCircle, FileX, Loader2 } from 'lucide-react';
import { Button } from './Button';

// Skeleton Loader
export const Skeleton = ({ className = '', ...props }) => (
  <div
    className={cn(
      'animate-pulse bg-neutral-200 rounded-md',
      className
    )}
    aria-busy="true"
    aria-label="Carregando conteúdo"
    {...props}
  />
);

// Empty State
interface EmptyStateProps {
  icon?: React.ElementType;
  title: string;
  description?: string;
  action?: {
    label: string;
    onClick: () => void;
  };
}

export const EmptyState = ({ 
  icon: Icon = FileX, 
  title, 
  description, 
  action 
}: EmptyStateProps) => (
  <div className="flex flex-col items-center justify-center py-12 px-4">
    <div className="w-16 h-16 bg-neutral-100 rounded-full flex items-center justify-center mb-4">
      <Icon className="w-8 h-8 text-neutral-400" />
    </div>
    <h3 className="text-lg font-medium text-neutral-900 mb-1">{title}</h3>
    {description && (
      <p className="text-sm text-neutral-500 text-center max-w-sm mb-4">
        {description}
      </p>
    )}
    {action && (
      <Button variant="primary" size="sm" onClick={action.onClick}>
        {action.label}
      </Button>
    )}
  </div>
);

// Error State
interface ErrorStateProps {
  title?: string;
  error: Error | string;
  onRetry?: () => void;
}

export const ErrorState = ({ 
  title = 'Erro ao carregar', 
  error, 
  onRetry 
}: ErrorStateProps) => (
  <div className="flex flex-col items-center justify-center py-12 px-4">
    <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mb-4">
      <AlertCircle className="w-8 h-8 text-red-600" />
    </div>
    <h3 className="text-lg font-medium text-neutral-900 mb-1">{title}</h3>
    <p className="text-sm text-neutral-500 text-center max-w-sm mb-4">
      {typeof error === 'string' ? error : error.message}
    </p>
    {onRetry && (
      <Button variant="outline" size="sm" onClick={onRetry}>
        Tentar novamente
      </Button>
    )}
  </div>
);

// Loading State
export const LoadingState = ({ message = 'Carregando...' }) => (
  <div className="flex flex-col items-center justify-center py-12">
    <Loader2 className="w-8 h-8 animate-spin text-primary-500 mb-4" />
    <p className="text-sm text-neutral-500">{message}</p>
  </div>
);

PARTE 2: IA MÉDICA COM GUARDRAILS
2.1 SERVIÇO DE IA SEGURO COM DE-IDENTIFICAÇÃO
javascript// CRIAR ARQUIVO: repomed-api/src/services/SecureAIService.js

const OpenAI = require('openai');
const crypto = require('crypto');
const { db } = require('../config/database');

class SecureAIService {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    
    // Configurações de segurança
    this.securityConfig = {
      maxTokens: 2000,
      temperature: 0.3,
      blockHighRiskDiagnosis: true,
      requireCitations: true,
      auditAll: true
    };
  }
  
  /**
   * De-identificar dados do paciente antes de enviar para IA
   */
  deIdentifyData(data) {
    const anonymized = { ...data };
    
    // Substituir informações sensíveis
    const sensitiveFields = ['name', 'cpf', 'rg', 'email', 'phone', 'address'];
    sensitiveFields.forEach(field => {
      if (anonymized[field]) {
        anonymized[field] = this.hashField(anonymized[field]);
      }
    });
    
    // Substituir datas por idade relativa
    if (anonymized.birthDate) {
      const age = this.calculateAge(anonymized.birthDate);
      anonymized.age = age;
      delete anonymized.birthDate;
    }
    
    return anonymized;
  }
  
  /**
   * Hash reversível para re-identificação posterior
   */
  hashField(value) {
    const hash = crypto.createHash('sha256');
    hash.update(value + process.env.DEIDENTIFY_SALT);
    return 'ANON_' + hash.digest('hex').substring(0, 8);
  }
  
  /**
   * Sugestão segura de diagnósticos com guardrails
   */
  async suggestDiagnosisSafe(symptoms, patientId) {
    try {
      // Buscar dados do paciente
      const patient = await db.query(
        'SELECT * FROM patients WHERE id = $1',
        [patientId]
      );
      
      // De-identificar
      const anonPatient = this.deIdentifyData(patient.rows[0]);
      
      // Prompt estruturado com guardrails
      const systemPrompt = `
        Você é um assistente médico que APENAS sugere possibilidades diagnósticas.
        
        REGRAS CRÍTICAS:
        1. NUNCA forneça diagnósticos definitivos
        2. SEMPRE use linguagem probabilística ("pode indicar", "sugere", "possível")
        3. SEMPRE cite fontes médicas reconhecidas
        4. SEMPRE recomende avaliação médica presencial
        5. NUNCA sugira tratamentos sem supervisão médica
        6. Para condições graves, SEMPRE indique urgência médica
        
        Retorne JSON estruturado com:
        - suggestions: array de diagnósticos possíveis
        - confidence: nível de confiança (low/medium/high)
        - urgency: urgência médica (routine/priority/urgent/emergency)
        - citations: fontes médicas utilizadas
        - warnings: avisos importantes
        - requiresImediateAttention: boolean
      `;
      
      const userPrompt = `
        Sintomas relatados: ${symptoms.join(', ')}
        Idade do paciente: ${anonPatient.age || 'não informada'}
        Condições crônicas: ${anonPatient.chronicConditions?.join(', ') || 'nenhuma'}
        
        Sugira diagnósticos possíveis seguindo as regras de segurança.
      `;
      
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        response_format: { type: 'json_object' },
        temperature: this.securityConfig.temperature,
        max_tokens: this.securityConfig.maxTokens,
      });
      
      const result = JSON.parse(response.choices[0].message.content);
      
      // Validar resposta
      if (result.requiresImediateAttention) {
        await this.alertUrgentCase(patientId, result);
      }
      
      // Bloquear diagnósticos de alto risco sem supervisão
      if (this.securityConfig.blockHighRiskDiagnosis) {
        result.suggestions = result.suggestions.filter(s => 
          !this.isHighRiskDiagnosis(s.cid10)
        );
      }
      
      // Auditar
      await this.auditAIInteraction({
        type: 'diagnosis_suggestion',
        patientId,
        input: { symptoms: symptoms.join(', ') },
        output: result,
        risk: result.urgency,
        timestamp: new Date()
      });
      
      return result;
      
    } catch (error) {
      console.error('Erro na sugestão de diagnóstico:', error);
      
      // Fallback seguro
      return {
        suggestions: [],
        error: 'Não foi possível processar a solicitação',
        requiresHumanReview: true
      };
    }
  }
  
  /**
   * Verificação de interações medicamentosas com bloqueios
   */
  async checkMedicationInteractionsSafe(medications, patientId) {
    try {
      const interactions = [];
      
      // Verificar cada par de medicamentos
      for (let i = 0; i < medications.length; i++) {
        for (let j = i + 1; j < medications.length; j++) {
          const interaction = await this.checkPairInteraction(
            medications[i],
            medications[j]
          );
          
          if (interaction) {
            interactions.push({
              ...interaction,
              severity: this.classifyInteractionSeverity(interaction),
              requiresOverride: interaction.severity === 'major' || interaction.severity === 'contraindicated'
            });
          }
        }
      }
      
      // Classificar resultado geral
      const maxSeverity = this.getMaxSeverity(interactions);
      const requiresPhysicianOverride = maxSeverity === 'major' || maxSeverity === 'contraindicated';
      
      // Se houver interação grave, registrar
      if (requiresPhysicianOverride) {
        await this.logHighRiskInteraction(patientId, medications, interactions);
      }
      
      return {
        safe: interactions.length === 0,
        interactions,
        maxSeverity,
        requiresPhysicianOverride,
        overrideReason: requiresPhysicianOverride ? 
          'Interação grave detectada. Requer confirmação médica consciente.' : null,
        alternatives: await this.suggestAlternatives(medications, interactions)
      };
      
    } catch (error) {
      // Em caso de erro, assumir não seguro
      return {
        safe: false,
        error: 'Não foi possível verificar interações',
        requiresManualCheck: true
      };
    }
  }
  
  /**
   * Auditar todas as interações com IA
   */
  async auditAIInteraction(data) {
    // Remover PHI antes de salvar
    const sanitized = this.sanitizeForAudit(data);
    
    await db.query(
      `INSERT INTO ai_audit_log 
       (type, tenant_id, user_id, input_hash, output_hash, risk_level, 
        decision, timestamp, session_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        sanitized.type,
        this.getCurrentTenantId(),
        this.getCurrentUserId(),
        this.hashData(sanitized.input),
        this.hashData(sanitized.output),
        sanitized.risk,
        sanitized.decision,
        sanitized.timestamp,
        this.getSessionId()
      ]
    );
  }
  
  /**
   * Classificar severidade de interação
   */
  classifyInteractionSeverity(interaction) {
    const severityKeywords = {
      contraindicated: ['contraindicado', 'fatal', 'morte', 'never'],
      major: ['grave', 'severa', 'maior', 'major', 'serious'],
      moderate: ['moderada', 'cuidado', 'moderate', 'caution'],
      minor: ['leve', 'menor', 'minor', 'mild']
    };
    
    const text = (interaction.description || '').toLowerCase();
    
    for (const [level, keywords] of Object.entries(severityKeywords)) {
      if (keywords.some(keyword => text.includes(keyword))) {
        return level;
      }
    }
    
    return 'unknown';
  }
  
  /**
   * Verificar se é diagnóstico de alto risco
   */
  isHighRiskDiagnosis(cid10) {
    const highRiskCodes = [
      'C00-C97', // Neoplasias
      'I20-I25', // Doenças isquêmicas do coração
      'I60-I69', // Doenças cerebrovasculares
      'F20-F29', // Esquizofrenia e transtornos
      'X60-X84', // Lesões autoprovocadas
    ];
    
    return highRiskCodes.some(range => this.cid10InRange(cid10, range));
  }
}

module.exports = new SecureAIService();

PARTE 3: ASSINATURA DIGITAL PAdES-LTV
3.1 IMPLEMENTAR ASSINATURA PAdES COMPLETA
javascript// CRIAR ARQUIVO: repomed-api/src/services/PAdESSignatureService.js

const forge = require('node-forge');
const { PDFDocument } = require('pdf-lib');
const axios = require('axios');
const moment = require('moment');

class PAdESSignatureService {
  constructor() {
    this.tsaUrl = process.env.TSA_URL || 'http://timestamp.entrust.net/TSS/RFC3161sha2TS';
    this.ocspUrl = process.env.OCSP_URL;
  }
  
  /**
   * Assinar documento com PAdES-B-LTV
   */
  async signPAdES(documentBuffer, certificate, privateKey) {
    try {
      // 1. Criar hash do documento
      const documentHash = this.createDocumentHash(documentBuffer);
      
      // 2. Obter timestamp (TSA)
      const timestamp = await this.getTimestamp(documentHash);
      
      // 3. Verificar status do certificado (OCSP)
      const ocspResponse = await this.getOCSPResponse(certificate);
      
      // 4. Criar assinatura CMS/PKCS#7
      const signature = await this.createCMSSignature({
        documentHash,
        certificate,
        privateKey,
        timestamp,
        ocspResponse
      });
      
      // 5. Incorporar no PDF como PAdES
      const signedPdf = await this.embedPAdESSignature(
        documentBuffer,
        signature,
        certificate,
        timestamp,
        ocspResponse
      );
      
      // 6. Adicionar DSS (Document Security Store) para LTV
      const ltvPdf = await this.addLTV(signedPdf, certificate, ocspResponse);
      
      return {
        signedDocument: ltvPdf,
        signature,
        timestamp,
        verificationData: {
          certificateChain: this.extractCertificateChain(certificate),
          ocspResponse,
          timestampToken: timestamp,
          signatureAlgorithm: 'SHA256withRSA',
          signaturePolicy: 'PAdES-B-LTV'
        }
      };
      
    } catch (error) {
      console.error('Erro ao assinar PAdES:', error);
      throw new Error('Falha na assinatura digital PAdES: ' + error.message);
    }
  }
  
  /**
   * Criar assinatura CMS com atributos PAdES
   */
  async createCMSSignature({ documentHash, certificate, privateKey, timestamp, ocspResponse }) {
    const p7 = forge.pkcs7.createSignedData();
    
    // Adicionar conteúdo
    p7.content = forge.util.createBuffer(documentHash, 'hex');
    
    // Adicionar certificado
    p7.addCertificate(certificate);
    
    // Configurar assinador com atributos PAdES
    const signerInfo = {
      key: privateKey,
      certificate,
      digestAlgorithm: forge.pki.oids.sha256,
      authenticatedAttributes: [
        {
          type: forge.pki.oids.contentType,
          value: forge.pki.oids.data
        },
        {
          type: forge.pki.oids.messageDigest
        },
        {
          type: forge.pki.oids.signingTime,
          value: new Date()
        },
        // Atributos PAdES específicos
        {
          type: '1.2.840.113549.1.9.16.2.47', // signingCertificateV2
          value: this.createSigningCertificateV2(certificate)
        },
        {
          type: '1.2.840.113549.1.9.16.2.15', // signaturePolicyIdentifier
          value: this.createSignaturePolicyIdentifier()
        }
      ],
      unauthenticatedAttributes: [
        {
          type: '1.2.840.113549.1.9.16.2.14', // timeStampToken
          value: timestamp
        }
      ]
    };
    
    p7.addSigner(signerInfo);
    
    // Assinar
    p7.sign({ detached: true });
    
    return p7;
  }
  
  /**
   * Obter timestamp de autoridade certificadora
   */
  async getTimestamp(hash) {
    const tsReq = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
      // version
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false,
        forge.asn1.integerToDer(1).getBytes()),
      // messageImprint
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
        // hashAlgorithm
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
          forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false,
            forge.asn1.oidToDer(forge.pki.oids.sha256).getBytes())
        ]),
        // hashedMessage
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, hash)
      ]),
      // reqPolicy (optional)
      // nonce
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false,
        forge.util.hexToBytes(forge.util.bytesToHex(forge.random.getBytesSync(8))))
    ]);
    
    const response = await axios.post(this.tsaUrl, forge.asn1.toDer(tsReq).getBytes(), {
      headers: {
        'Content-Type': 'application/timestamp-query',
        'Accept': 'application/timestamp-reply'
      },
      responseType: 'arraybuffer'
    });
    
    return Buffer.from(response.data);
  }
  
  /**
   * Obter resposta OCSP
   */
  async getOCSPResponse(certificate) {
    const certId = this.createCertificateId(certificate);
    
    const ocspReq = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
      // tbsRequest
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
        // version
        forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false,
            forge.asn1.integerToDer(0).getBytes())
        ]),
        // requestList
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
          forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
            // reqCert (CertID)
            certId
          ])
        ])
      ])
    ]);
    
    const response = await axios.post(this.ocspUrl, forge.asn1.toDer(ocspReq).getBytes(), {
      headers: {
        'Content-Type': 'application/ocsp-request',
        'Accept': 'application/ocsp-response'
      },
      responseType: 'arraybuffer'
    });
    
    return Buffer.from(response.data);
  }
  
  /**
   * Adicionar LTV (Long-Term Validation)
   */
  async addLTV(pdfBuffer, certificate, ocspResponse) {
    const pdfDoc = await PDFDocument.load(pdfBuffer);
    
    // Criar DSS Dictionary
    const dss = pdfDoc.context.obj({
      Type: 'DSS',
      Certs: [], // Certificados da cadeia
      OCSPs: [ocspResponse], // Respostas OCSP
      CRLs: [], // Lista de revogação (se aplicável)
      VRI: {} // Validation Related Information
    });
    
    // Adicionar ao catálogo do PDF
    const catalog = pdfDoc.catalog;
    catalog.set('DSS', dss);
    
    // Adicionar timestamp de arquivamento
    const archiveTimestamp = await this.getTimestamp(
      Buffer.from(await pdfDoc.save())
    );
    
    // Salvar PDF com LTV
    return Buffer.from(await pdfDoc.save());
  }
  
  /**
   * Validar assinatura PAdES
   */
  async validatePAdES(pdfBuffer) {
    try {
      const pdfDoc = await PDFDocument.load(pdfBuffer);
      
      // Extrair assinatura
      const signature = this.extractSignature(pdfDoc);
      if (!signature) {
        return { valid: false, reason: 'Nenhuma assinatura encontrada' };
      }
      
      // Verificar integridade
      const documentHash = this.createDocumentHash(
        this.getSignedContent(pdfDoc)
      );
      
      const signatureValid = this.verifySignature(
        signature,
        documentHash
      );
      
      if (!signatureValid) {
        return { valid: false, reason: 'Assinatura inválida' };
      }
      
      // Verificar timestamp
      const timestampValid = await this.verifyTimestamp(signature.timestamp);
      
      // Verificar OCSP
      const ocspValid = await this.verifyOCSP(signature.ocspResponse);
      
      // Verificar cadeia de certificação
      const chainValid = await this.verifyCertificateChain(signature.certificate);
      
      return {
        valid: signatureValid && timestampValid && ocspValid && chainValid,
        details: {
          signature: signatureValid,
          timestamp: timestampValid,
          ocsp: ocspValid,
          chain: chainValid,
          signer: this.extractSignerInfo(signature.certificate),
          signedAt: signature.signingTime,
          policy: 'PAdES-B-LTV'
        }
      };
      
    } catch (error) {
      return { valid: false, reason: error.message };
    }
  }
}

module.exports = new PAdESSignatureService();

PARTE 4: OBSERVABILIDADE E MONITORAMENTO
4.1 CONFIGURAR RUM (REAL USER MONITORING)
typescript// CRIAR ARQUIVO: repomed-web/src/lib/monitoring.ts

import { getCLS, getFCP, getFID, getLCP, getTTFB, INP } from 'web-vitals';
import * as Sentry from '@sentry/react';

class MonitoringService {
  private tenantId: string;
  private userId: string;
  private sessionId: string;
  
  constructor() {
    this.sessionId = this.generateSessionId();
    this.initializeSentry();
    this.initializeWebVitals();
  }
  
  /**
   * Inicializar Sentry com sanitização de PHI
   */
  private initializeSentry() {
    Sentry.init({
      dsn: import.meta.env.VITE_SENTRY_DSN,
      environment: import.meta.env.VITE_ENV,
      integrations: [
        new Sentry.BrowserTracing(),
        new Sentry.Replay({
          // Mascarar dados sensíveis
          maskAllText: true,
          maskAllInputs: true,
          blockAllMedia: false,
          // Não gravar em páginas com PHI
          beforeAddRecordingEvent: (event) => {
            const currentPath = window.location.pathname;
            const phiPages = ['/patients', '/documents', '/prescriptions'];
            
            if (phiPages.some(page => currentPath.includes(page))) {
              return null; // Não gravar
            }
            return event;
          }
        })
      ],
      
      // Sanitizar dados antes de enviar
      beforeSend(event, hint) {
        // Remover PHI dos dados
        event = this.sanitizePHI(event);
        
        // Adicionar contexto do tenant
        event.tags = {
          ...event.tags,
          tenant: this.tenantId,
          session: this.sessionId
        };
        
        return event;
      },
      
      // Taxa de amostragem
      tracesSampleRate: import.meta.env.PROD ? 0.1 : 1.0,
      replaysSessionSampleRate: 0.1,
      replaysOnErrorSampleRate: 1.0,
    });
  }
  
  /**
   * Monitorar Web Vitals por tenant
   */
  private initializeWebVitals() {
    const reportMetric = (metric: any) => {
      // Enviar para backend
      this.sendMetric({
        name: metric.name,
        value: metric.value,
        rating: metric.rating,
        delta: metric.delta,
        id: metric.id,
        tenantId: this.tenantId,
        userId: this.userId,
        sessionId: this.sessionId,
        url: window.location.href,
        timestamp: new Date().toISOString()
      });
      
      // Log para console em dev
      if (import.meta.env.DEV) {
        console.log(`[Web Vital] ${metric.name}:`, metric.value, metric.rating);
      }
    };
    
    // Core Web Vitals
    getCLS(reportMetric);
    getFCP(reportMetric);
    getFID(reportMetric);
    getLCP(reportMetric);
    getTTFB(reportMetric);
    
    // INP (Interaction to Next Paint)
    if ('INP' in window) {
      INP(reportMetric);
    }
  }
  
  /**
   * Sanitizar PHI dos eventos
   */
  private sanitizePHI(event: any): any {
    const sanitized = { ...event };
    
    // Campos a remover
    const phiFields = [
      'cpf', 'rg', 'patient_name', 'patient_email',
      'patient_phone', 'patient_address', 'diagnosis'
    ];
    
    // Remover de request
    if (sanitized.request?.data) {
      phiFields.forEach(field => {
        if (sanitized.request.data[field]) {
          sanitized.request.data[field] = '[REDACTED]';
        }
      });
    }
    
    // Remover de breadcrumbs
    if (sanitized.breadcrumbs) {
      sanitized.breadcrumbs = sanitized.breadcrumbs.map((crumb: any) => {
        if (crumb.data) {
          phiFields.forEach(field => {
            if (crumb.data[field]) {
              crumb.data[field] = '[REDACTED]';
            }
          });
        }
        return crumb;
      });
    }
    
    return sanitized;
  }
  
  /**
   * Enviar métrica para backend
   */
  private async sendMetric(metric: any) {
    try {
      await fetch('/api/metrics', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(metric)
      });
    } catch (error) {
      console.error('Failed to send metric:', error);
    }
  }
  
  /**
   * Métodos públicos
   */
  public setTenant(tenantId: string) {
    this.tenantId = tenantId;
    Sentry.setTag('tenant', tenantId);
  }
  
  public setUser(userId: string) {
    this.userId = userId;
    Sentry.setUser({ id: userId });
  }
  
  public trackEvent(name: string, data?: any) {
    // Sanitizar dados antes de enviar
    const sanitizedData = this.sanitizePHI({ data }).data;
    
    Sentry.addBreadcrumb({
      category: 'user-action',
      message: name,
      level: 'info',
      data: sanitizedData
    });
    
    // Enviar para analytics também
    this.sendMetric({
      type: 'event',
      name,
      data: sanitizedData,
      tenantId: this.tenantId,
      userId: this.userId,
      sessionId: this.sessionId,
      timestamp: new Date().toISOString()
    });
  }
  
  public captureError(error: Error, context?: any) {
    Sentry.captureException(error, {
      contexts: {
        custom: this.sanitizePHI(context)
      }
    });
  }
  
  private generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

export const monitoring = new MonitoringService();

PARTE 5: COMPONENTES DE TABELA VIRTUALIZADA
5.1 DATA TABLE MÉDICO COM VIRTUALIZAÇÃO
tsx// CRIAR ARQUIVO: repomed-web/src/components/ui/DataTable.tsx

import { useVirtualizer } from '@tanstack/react-virtual';
import { useTable, useSortBy, useFilters, usePagination } from 'react-table';
import { ChevronUp, ChevronDown, Search } from 'lucide-react';
import { EmptyState, LoadingState } from './States';

interface DataTableProps<T extends object> {
  data: T[];
  columns: any[];
  loading?: boolean;
  error?: Error;
  onRowClick?: (row: T) => void;
  virtualizeThreshold?: number;
  emptyMessage?: string;
}

export function DataTable<T extends object>({
  data,
  columns,
  loading = false,
  error,
  onRowClick,
  virtualizeThreshold = 50,
  emptyMessage = 'Nenhum dado encontrado'
}: DataTableProps<T>) {
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow,
    state,
    setGlobalFilter
  } = useTable(
    {
      columns,
      data,
      initialState: {
        pageSize: virtualizeThreshold
      }
    },
    useFilters,
    useSortBy,
    usePagination
  );
  
  // Virtualização para listas grandes
  const parentRef = React.useRef<HTMLDivElement>(null);
  
  const rowVirtualizer = useVirtualizer({
    count: rows.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 52,
    overscan: 10
  });
  
  if (loading) {
    return <LoadingState message="Carregando dados..." />;
  }
  
  if (error) {
    return <ErrorState error={error} />;
  }
  
  if (data.length === 0) {
    return <EmptyState title={emptyMessage} />;
  }
  
  const shouldVirtualize = rows.length > virtualizeThreshold;
  
  return (
    <div className="w-full">
      {/* Search */}
      <div className="mb-4">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-neutral-400" />
          <input
            type="text"
            placeholder="Buscar..."
            className="w-full pl-10 pr-4 py-2 border border-neutral-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
            onChange={(e) => setGlobalFilter(e.target.value)}
          />
        </div>
      </div>
      
      {/* Table */}
      <div className="border border-neutral-200 rounded-lg overflow-hidden">
        <table {...getTableProps()} className="w-full">
          <thead className="bg-neutral-50">
            {headerGroups.map(headerGroup => (
              <tr {...headerGroup.getHeaderGroupProps()}>
                {headerGroup.headers.map(column => (
                  <th
                    {...column.getHeaderProps(column.getSortByToggleProps())}
                    className="px-4 py-3 text-left text-xs font-medium text-neutral-500 uppercase tracking-wider cursor-pointer hover:bg-neutral-100"
                  >
                    <div className="flex items-center gap-2">
                      {column.render('Header')}
                      {column.isSorted && (
                        column.isSortedDesc ? 
                          <ChevronDown className="w-4 h-4" /> : 
                          <ChevronUp className="w-4 h-4" />
                      )}
                    </div>
                  </th>
                ))}
              </tr>
            ))}
          </thead>
          
          <tbody {...getTableBodyProps()}>
            {shouldVirtualize ? (
              // Renderização virtualizada
              <div
                ref={parentRef}
                style={{ height: '600px', overflow: 'auto' }}
              >
                <div
                  style={{
                    height: `${rowVirtualizer.getTotalSize()}px`,
                    width: '100%',
                    position: 'relative'
                  }}
                >
                  {rowVirtualizer.getVirtualItems().map(virtualRow => {
                    const row = rows[virtualRow.index];
                    prepareRow(row);
                    
                    return (
                      <tr
                        {...row.getRowProps()}
                        key={row.id}
                        style={{
                          position: 'absolute',
                          top: 0,
                          left: 0,
                          width: '100%',
                          height: `${virtualRow.size}px`,
                          transform: `translateY(${virtualRow.start}px)`
                        }}
                        className="hover:bg-neutral-50 cursor-pointer border-b border-neutral-200"
                        onClick={() => onRowClick?.(row.original)}
                      >
                        {row.cells.map(cell => (
                          <td
                            {...cell.getCellProps()}
                            className="px-4 py-3 text-sm text-neutral-900"
                          >
                            {cell.render('Cell')}
                          </td>
                        ))}
                      </tr>
                    );
                  })}
                </div>
              </div>
            ) : (
              // Renderização normal
              rows.map(row => {
                prepareRow(row);
                return (
                  <tr
                    {...row.getRowProps()}
                    className="hover:bg-neutral-50 cursor-pointer border-b border-neutral-200"
                    onClick={() => onRowClick?.(row.original)}
                  >
                    {row.cells.map(cell => (
                      <td
                        {...cell.getCellProps()}
                        className="px-4 py-3 text-sm text-neutral-900"
                      >
                        {cell.render('Cell')}
                      </td>
                    ))}
                  </tr>
                );
              })
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}

INSTRUÇÕES FINAIS DE IMPLEMENTAÇÃO
ORDEM DE EXECUÇÃO:

Aplicar correções imediatas no frontend (30 min)
Implementar componentes de estado padronizados (1h)
Configurar IA médica segura com guardrails (4h)
Implementar assinatura PAdES-LTV (6h)
Configurar monitoramento e observabilidade (2h)
Implementar DataTable virtualizada (2h)

CHECKLIST DE VALIDAÇÃO:

 Todos os componentes com aria-labels corretos
 Button com type="button" por padrão
 Estados padronizados (Loading, Empty, Error, Skeleton)
 IA com de-identificação funcionando
 Guardrails bloqueando interações graves
 Assinatura PAdES com timestamp e OCSP
 Sentry configurado sem PHI
 Web Vitals sendo coletados por tenant
 DataTable virtualizando listas grandes
 Audit log completo de interações IA

CONFIGURAÇÕES ADICIONAIS:
env# Adicionar ao .env do backend
TSA_URL=http://timestamp.entrust.net/TSS/RFC3161sha2TS
OCSP_URL=http://ocsp.entrust.net
DEIDENTIFY_SALT=random_salt_here
SENTRY_DSN_BACKEND=https://...@sentry.io/...

# Adicionar ao .env do frontend
VITE_SENTRY_DSN=https://...@sentry.io/...
VITE_ENABLE_MONITORING=true
Esta implementação corrige todos os pontos críticos identificados, adiciona camadas robustas de segurança para IA médica, implementa assinatura digital conforme padrões PAdES-LTV, e estabelece observabilidade completa sem comprometer dados sensíveis dos pacientes.