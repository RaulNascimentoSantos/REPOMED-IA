epo Med — Tokens, Zod Schemas E Verificação Pública (/verify/:hash) – Pronto Para Claude Coder
Instruções para o Claude Coder

Contexto: Projeto RepoMed IA com frontend React + Vite + Tailwind (JS/alguns TS) em repomed-web/ e backend Fastify + PostgreSQL em repomed-api/. Abaixo está um pacote fechado para implementar design tokens, 5 schemas Zod e a verificação pública de assinaturas (/verify/:hash).

Objetivo: Criar arquivos conforme os blocos abaixo, ajustar configs, e garantir que rodem em dev. Manter padrões do projeto.

1) Design System – Tokens (CSS Vars + TS)
1.1 Arquivo: repomed-web/src/styles/tokens.css
/* RepoMed IA — Design Tokens (CSS Variables)
   Paleta clínica neutra com suporte a dark theme e contraste AA.
   Use via Tailwind mapeado para var(). */
:root {
  /* Cores OKLCH (preferência), com fallback HEX para navegadores antigos */
  --brand-50: oklch(0.97 0.02 240);      /* #eef2ff aprox */
  --brand-100: oklch(0.92 0.04 240);
  --brand-200: oklch(0.86 0.06 240);
  --brand-300: oklch(0.80 0.08 240);
  --brand-400: oklch(0.74 0.10 240);
  --brand-500: oklch(0.68 0.12 240);     /* primária padrão */
  --brand-600: oklch(0.62 0.12 240);
  --brand-700: oklch(0.56 0.10 240);
  --brand-800: oklch(0.50 0.08 240);
  --brand-900: oklch(0.44 0.06 240);


  --teal-500: oklch(0.72 0.11 180);
  --green-500: oklch(0.72 0.12 160);
  --yellow-500: oklch(0.88 0.12 95);
  --red-500: oklch(0.62 0.15 25);


  --bg: #0b1020;           /* usado em dark */
  --bg-elev: #0f152a;      
  --surface: #101827;      
  --text: #0b1220;         /* usado em light */
  --text-muted: #475569;


  /* Tipografia */
  --font-sans: ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Cascadia Code", monospace;


  /* Espaçamento (8px grid) */
  --space-1: 0.25rem; /* 4px */
  --space-2: 0.5rem;  /* 8px */
  --space-3: 0.75rem; /* 12px */
  --space-4: 1rem;    /* 16px */
  --space-6: 1.5rem;  /* 24px */
  --space-8: 2rem;    /* 32px */
  --space-12: 3rem;   /* 48px */


  /* Radius e sombras */
  --radius-sm: 0.5rem;     /* 8px */
  --radius-md: 0.75rem;    /* 12px */
  --radius-lg: 1rem;       /* 16px */
  --shadow-1: 0 1px 2px rgba(0,0,0,.08);
  --shadow-2: 0 6px 20px rgba(0,0,0,.12);
}


/**** Tema Light (default) ****/
:root {
  --bg-app: #f7fafc;
  --fg-app: #0f172a;
  --panel: #ffffff;
  --border: rgba(2,6,23,.08);
  --brand: var(--brand-500);
}


/**** Tema Dark ****/
[data-theme="dark"] {
  --bg-app: var(--bg);
  --fg-app: #e5edff;
  --panel: var(--bg-elev);
  --border: rgba(148,163,184,.18);
  --brand: var(--brand-500);
}
1.2 Arquivo: repomed-web/src/design-system/tokens.ts
// RepoMed IA — Tokens (TypeScript)
// Uso: import { tokens } from "@/design-system/tokens";
export const tokens = {
  colors: {
    brand: {
      50: 'oklch(0.97 0.02 240)',
      100: 'oklch(0.92 0.04 240)',
      200: 'oklch(0.86 0.06 240)',
      300: 'oklch(0.80 0.08 240)',
      400: 'oklch(0.74 0.10 240)',
      500: 'oklch(0.68 0.12 240)',
      600: 'oklch(0.62 0.12 240)',
      700: 'oklch(0.56 0.10 240)',
      800: 'oklch(0.50 0.08 240)',
      900: 'oklch(0.44 0.06 240)'
    },
    semantic: {
      success: 'oklch(0.72 0.12 160)',
      warning: 'oklch(0.88 0.12 95)',
      danger:  'oklch(0.62 0.15 25)'
    }
  },
  radius: { sm: 8, md: 12, lg: 16 },
  spacing: { 1: 4, 2: 8, 3: 12, 4: 16, 6: 24, 8: 32, 12: 48 },
  shadow: {
    1: '0 1px 2px rgba(0,0,0,.08)',
    2: '0 6px 20px rgba(0,0,0,.12)'
  },
  typography: {
    fontSans: 'var(--font-sans)',
    fontMono: 'var(--font-mono)'
  }
} as const;
1.3 Patch: repomed-web/tailwind.config.js (mapear CSS vars)
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    './index.html',
    './src/**/*.{js,jsx,ts,tsx}',
  ],
  theme: {
    extend: {
      colors: {
        brand: {
          50: 'var(--brand-50)',
          100: 'var(--brand-100)',
          200: 'var(--brand-200)',
          300: 'var(--brand-300)',
          400: 'var(--brand-400)',
          500: 'var(--brand-500)',
          600: 'var(--brand-600)',
          700: 'var(--brand-700)',
          800: 'var(--brand-800)',
          900: 'var(--brand-900)'
        }
      },
      borderRadius: {
        md: 'var(--radius-md)',
        lg: 'var(--radius-lg)'
      },
      boxShadow: {
        sm: 'var(--shadow-1)',
        lg: 'var(--shadow-2)'
      }
    }
  }
}

Ação: importar tokens.css no repomed-web/src/index.css (primeira linha):

@import './styles/tokens.css';
2) Schemas Zod (5 telas críticas)

Pasta destino: repomed-web/src/lib/schemas/

Nota: O projeto usa React Hook Form. Estes schemas expõem types e mensagens BR. Incluem máscaras/validações: CPF, CRM, CNS, datas BR (DD/MM/AAAA).

2.1 patient.schema.ts
import { z } from 'zod';


const cpfRegex = /^(\d{3}\.\d{3}\.\d{3}-\d{2}|\d{11})$/;
const dateBrRegex = /^(0?[1-9]|[12][0-9]|3[01])\/(0?[1-9]|1[012])\/\d{4}$/;


export const PatientSchema = z.object({
  name: z.string().min(3, 'Informe o nome completo'),
  cpf: z.string().regex(cpfRegex, 'CPF inválido').transform((s) => s.replace(/\D/g, '')),
  birthDate: z.string().regex(dateBrRegex, 'Data no formato DD/MM/AAAA'),
  allergies: z.array(z.string().min(2)).default([]),
  medicalConditions: z.array(z.string().min(2)).default([]),
});
export type Patient = z.infer<typeof PatientSchema>;
2.2 physician.schema.ts
import { z } from 'zod';


// Formato comum de CRM no BR: 4-7 dígitos + UF, ex: 123456/MG
const crmRegex = /^(\d{4,7})\/(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RS|RO|RR|SC|SP|SE|TO)$/i;


export const PhysicianSchema = z.object({
  name: z.string().min(3, 'Nome obrigatório'),
  email: z.string().email('E-mail inválido'),
  crm: z.string().regex(crmRegex, 'CRM no formato 123456/UF').transform((s) => s.toUpperCase()),
  specialty: z.string().min(2, 'Especialidade obrigatória'),
});
export type Physician = z.infer<typeof PhysicianSchema>;
2.3 prescription.schema.ts
import { z } from 'zod';


export const PrescriptionItemSchema = z.object({
  medication: z.string().min(2, 'Informe o medicamento'),
  dosage: z.string().min(1, 'Informe a posologia'),
  frequency: z.string().min(1, 'Informe a frequência'),
  duration: z.string().min(1, 'Informe a duração'),
  notes: z.string().optional(),
});


export const PrescriptionSchema = z.object({
  patientId: z.string().uuid('Paciente inválido'),
  physicianId: z.string().uuid('Médico inválido'),
  items: z.array(PrescriptionItemSchema).min(1, 'Inclua ao menos 1 item'),
  warningsAccepted: z.boolean().refine((v) => v, 'Confirme a revisão de interações'),
});
export type Prescription = z.infer<typeof PrescriptionSchema>;
2.4 document.schema.ts
import { z } from 'zod';


export const DocumentSchema = z.object({
  title: z.string().min(5, 'Título muito curto'),
  type: z.enum(['receita','atestado','laudo','relatorio','solicitacao']),
  patientId: z.string().uuid(),
  doctorId: z.string().uuid(),
  content: z.string().min(20, 'Conteúdo mínimo de 20 caracteres'),
  status: z.enum(['draft','pending','signed']).default('draft'),
});
export type MedicalDocument = z.infer<typeof DocumentSchema>;
2.5 signature.schema.ts
import { z } from 'zod';


export const SignatureSchema = z.object({
  documentId: z.string().uuid('Documento inválido'),
  certificateType: z.enum(['A1','A3']),
  pin: z.string().min(4, 'PIN obrigatório'),
  acceptLegalTerms: z.boolean().refine((v) => v, 'Confirme os termos legais'),
});
export type SignatureRequest = z.infer<typeof SignatureSchema>;
3) Verificação Pública de Assinaturas
3.1 Migração (alterar tabela existente): repomed-api/src/migrations/2025-09-01_add_signature_hash.sql
-- Adiciona hash público e URL de verificação (não sensíveis)
ALTER TABLE document_signatures
  ADD COLUMN IF NOT EXISTS doc_hash TEXT UNIQUE,
  ADD COLUMN IF NOT EXISTS verification_url TEXT,
  ADD COLUMN IF NOT EXISTS tsa_timestamp TIMESTAMPTZ;


CREATE INDEX IF NOT EXISTS idx_document_signatures_hash ON document_signatures(doc_hash);
3.2 Serviço: repomed-api/src/services/verifyService.js
import crypto from 'node:crypto';
import { pool } from '../models/db.js'; // ajuste conforme seu helper de DB


export async function computeDocHash(buffer) {
  return crypto.createHash('sha256').update(buffer).digest('hex');
}


export async function getSignatureByHash(hash) {
  const q = 'SELECT ds.*, md.title, u.crm, u.email FROM document_signatures ds\n' +
            'JOIN medical_documents md ON md.id = ds.document_id\n' +
            'JOIN users u ON u.id = ds.signer_id\n' +
            'WHERE ds.doc_hash = $1 LIMIT 1';
  const { rows } = await pool.query(q, [hash]);
  return rows[0] || null;
}
3.3 Rota Fastify: repomed-api/src/routes/verify.js
/**
 * GET /api/verify/:hash  -> JSON com metadados de assinatura
 * GET /verify/:hash      -> Página pública (HTML simples) para validação humana
 */
export default async function verifyRoutes(fastify) {
  const { getSignatureByHash } = await import('../services/verifyService.js');


  fastify.get('/api/verify/:hash', async (req, reply) => {
    const { hash } = req.params;
    const row = await getSignatureByHash(hash);
    if (!row) return reply.code(404).send({ ok: false, error: 'Documento não encontrado' });


    return {
      ok: true,
      hash,
      documentId: row.document_id,
      title: row.title,
      signer: { id: row.signer_id, crm: row.crm, email: row.email },
      tsaTimestamp: row.tsa_timestamp,
      verificationUrl: row.verification_url || `${req.protocol}://${req.hostname}/verify/${hash}`,
      // Nota: Assinatura PAdES-LTV é verificada no lado do cliente (PDF/A com LTV) ou serviço dedicado.
    };
  });


  fastify.get('/verify/:hash', async (req, reply) => {
    const { hash } = req.params;
    const base = `${req.protocol}://${req.hostname}`;
    try {
      const res = await fastify.inject({ method: 'GET', url: `/api/verify/${hash}` });
      if (res.statusCode !== 200) return reply.code(404).type('text/html').send('<h1>Documento não encontrado</h1>');
      const data = res.json();
      const html = `<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Verificação de Assinatura — RepoMed</title>
  <style>
    body{font-family:ui-sans-serif,system-ui;background:#0b1020;color:#e5edff;display:grid;place-items:center;height:100dvh;margin:0}
    .card{background:#0f152a;border:1px solid rgba(148,163,184,.18);padding:24px;border-radius:16px;box-shadow:0 6px 20px rgba(0,0,0,.12);width:min(720px,92vw)}
    .ok{color:#10b981}.warn{color:#f59e0b}.muted{color:#94a3b8}
    code{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Cascadia Code", monospace}
  </style>
</head>
<body>
  <div class="card">
    <h1>Verificação de Assinatura</h1>
    <p class="muted">Hash: <code>${hash}</code></p>
    <dl>
      <dt>Documento</dt><dd>${data.title} (ID: ${data.documentId})</dd>
      <dt>Assinante</dt><dd>${data.signer.crm} · ${data.signer.email}</dd>
      <dt>Timestamp</dt><dd>${data.tsaTimestamp ?? '—'}</dd>
    </dl>
    <p>API: <a href="${base}/api/verify/${hash}">${base}/api/verify/${hash}</a></p>
  </div>
</body>
</html>`;
      return reply.type('text/html').send(html);
    } catch (e) {
      fastify.log.error(e);
      return reply.code(500).type('text/html').send('<h1>Erro interno</h1>');
    }
  });
}
3.4 Registro da rota no servidor: repomed-api/src/server.js (trecho)
import verifyRoutes from './routes/verify.js';
// ... após registrar outras rotas
app.register(verifyRoutes);
4) Frontend — Página de Verificação (consome a API)
4.1 Arquivo: repomed-web/src/pages/VerifyPage.jsx
import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import api from '../lib/api';


export default function VerifyPage(){
  const { hash } = useParams();
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);


  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const res = await api.get(`/api/verify/${hash}`);
        if (mounted) setData(res.data);
      } catch (e) {
        setError('Documento não encontrado ou erro na verificação.');
      } finally {
        setLoading(false);
      }
    })();
    return () => { mounted = false; };
  }, [hash]);


  if (loading) return <div className="p-8 text-slate-500">Carregando verificação…</div>;
  if (error) return <div className="p-8 text-red-500">{error}</div>;


  return (
    <div className="max-w-3xl mx-auto p-6">
      <div className="bg-[var(--panel)] text-[var(--fg-app)] rounded-lg shadow-lg p-6 border border-[var(--border)]">
        <h1 className="text-xl font-semibold mb-2">Verificação de Assinatura</h1>
        <p className="text-sm text-slate-500">Hash: <code>{data.hash}</code></p>
        <dl className="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
          <div><dt className="text-slate-400 text-xs">Documento</dt><dd className="font-medium">{data.title} (ID: {data.documentId})</dd></div>
          <div><dt className="text-slate-400 text-xs">Assinante</dt><dd className="font-medium">{data.signer.crm} · {data.signer.email}</dd></div>
          <div><dt className="text-slate-400 text-xs">Timestamp</dt><dd className="font-medium">{data.tsaTimestamp || '—'}</dd></div>
        </dl>
        <a className="mt-6 inline-block text-sm underline" href={data.verificationUrl}>Abrir verificação pública</a>
      </div>
    </div>
  );
}
5) Testes manuais rápidos

Rodar migração SQL no banco.

Garantir que documentos assinados gravem doc_hash (pelo serviço de assinatura) — pode simular inserindo uma linha em document_signatures com um doc_hash conhecido.

Acessar http://localhost:3010/verify/<hash> e validar render.

Acessar http://localhost:8081/api/verify/<hash> e checar JSON.

6) Critérios de aceite




Observação: A assinatura PAdES-LTV real depende do SignatureService. Esta entrega trata verificação pública por hash e UX da verificação. Integração com carimbo de tempo/OCSP fica no serviço já previsto.

perfeito, Raul! já deixei tudo “no ponto” para o Claude Coder: tokens de design, 5 schemas Zod e a verificação pública (/verify/:hash) — com arquivos, paths e trechos prontos pra ele gerar.

abre o documento na lateral com o título:

“RepoMed — Tokens, Zod Schemas e Verificação Pública (/verify/:hash) – Pronto para Claude Coder”

lá tem:

os arquivos exatos para criar (frontend e backend),

patches de config (Tailwind, import de tokens.css),

migração SQL,

rota Fastify /api/verify/:hash + página pública /verify/:hash,

VerifyPage.jsx consumindo a API,

critérios de aceite.